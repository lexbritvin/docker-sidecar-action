name: 'Secure Docker Remote Access'
description: 'Sets up secure remote Docker daemon access through SSH tunneling with TLS authentication'

branding:
  icon: 'shield'
  color: 'blue'

inputs:
  # SSH Server Configuration
  ssh-server-host:
    required: false
    description: |
      SSH server hostname or IP address for client connections.
      When left empty, this will be automatically determined:
      1. If `ssh-jump-forward` is `:generate`, a hostname will be generated by this action for use on the jump host
      2. If the jump host provides a direct connection hostname or IP, that will be used
      3. Otherwise defaults to 'localhost' for direct connections.
      
      Note: Not all jump host SSH servers support hostname aliases in port forwarding.
      If unsupported, use `ssh-jump-forward: '0'` for random port assignment. 
      See `ssh-jump-forward`.
    default: ''

  ssh-server-port:
    description: 'SSH server port for client connections'
    required: false
    default: '2222'

  ssh-server-user:
    description: 'SSH username for the server and authorized keys. Use :current to get the current user name'
    required: false
    default: ':current'

  ssh-server-authorized-keys:
    description: 'Authorized public keys (one per line) for SSH Server authentication'
    required: false

  # Jump Host Configuration
  ssh-jump-host:
    required: false
    default: ''
    description: 'SSH jump host server for tunneling SSH server access'

  ssh-jump-port:
    required: false
    default: '22'
    description: 'SSH jump host port for tunneling SSH server access'

  ssh-jump-user:
    required: false
    default: ''
    description: 'SSH jump host username. Use :generate to create a unique username automatically. See `ssh-jump-forward` parameter.'

  ssh-jump-forward:
    required: false
    description: |
      Port forwarding configuration for jump host:
      - '0' for random port and public access (serveo.net, pinggy.io, or arbitrary server)
      - ':generate' to use a generated host alias (Public SSH jump hosts like ssh-j.com, serveo.net)
      - Custom format like `2222` or `myhost:2222` for specific host and port
      - Empty to disable jump host when other connection methods are available
    default: ''

  ssh-jump-private-key:
    required: false
    default: ''
    description: 'Private key content for authenticating with the SSH jump host'

  ssh-jump-private-key-path:
    required: false
    default: ''
    description: 'Private key path for authenticating with the SSH jump host'

  ssh-jump-host-keys:
    required: false
    description: 'SSH host keys for jump server verification (known_hosts format)'
    default: ''

  ssh-jump-extra-flags:
    description: 'Additional SSH flags for jump host connection'
    required: false
    default: ''

  # Bore Tunneling Configuration
  use-bore:
    description: 'Use bore tunneling instead of SSH port forwarding for exposing the SSH server'
    required: false
    default: 'false'

  bore-server:
    description: 'Bore server address (e.g., bore.pub:2200). Required when use-bore is true'
    required: false
    default: 'bore.pub'

  bore-secret:
    description: 'Secret key for bore server authentication. Optional but recommended for security'
    required: false
    default: ''

  # Docker TLS Configuration
  enable-tls:
    required: false
    default: 'true'
    description: 'Enable TLS encryption for Docker daemon communication (recommended for security)'

  tls-certificate-domains:
    description: 'Comma-separated list of domains for TLS certificates (includes localhost by default)'
    default: 'localhost'
    required: false

  # Output Configuration
  docker-connection-artifact-name:
    description: 'Name for the Docker connection artifacts uploaded'
    default: 'docker-conn-details'
    required: false

runs:
  using: "composite"
  steps:
    # ============================================================================
    # ENVIRONMENT VALIDATION
    # ============================================================================
    - name: üîç Validate execution environment
      shell: bash
      run: |
        echo "::group::üîç Environment Validation"
        
        # Validate Linux environment
        if [[ "$RUNNER_OS" != "Linux" ]]; then
          echo "‚ùå This action requires a Linux runner environment. Current OS: $RUNNER_OS"
          exit 1
        fi
        
        echo "‚úÖ Running on Linux environment: $RUNNER_OS"
        
        # Display system information for debugging
        echo "üìã System Information:"
        echo "  - Kernel: $(uname -r)"
        echo "  - Distribution: $(lsb_release -d 2>/dev/null | cut -f2 || echo 'Unknown')"
        echo "  - Architecture: $(uname -m)"
        echo "  - Available Memory: $(free -h | grep '^Mem:' | awk '{print $2}')"
        echo "  - Available Disk: $(df -h / | tail -1 | awk '{print $4}')"
        
        echo "::endgroup::"

    # ============================================================================
    # SYSTEM DEPENDENCIES INSTALLATION
    # ============================================================================
    - name: üì¶ Install system dependencies
      shell: bash
      run: |
        echo "::group::üì¶ Installing System Dependencies"
        
        # Function to detect package manager and install packages
        install_packages() {
          local packages=("$@")
        
          if command -v apt-get &> /dev/null; then
            echo "üêß Detected Debian/Ubuntu system"
            sudo apt-get update -qq
            sudo apt-get install -y "${packages[@]}"
          elif command -v yum &> /dev/null; then
            echo "üé© Detected RHEL/CentOS system"
            sudo yum install -y "${packages[@]}"
          elif command -v dnf &> /dev/null; then
            echo "üî• Detected Fedora/RHEL 8+ system"
            sudo dnf install -y "${packages[@]}"
          elif command -v zypper &> /dev/null; then
            echo "ü¶é Detected openSUSE/SLES system"
            sudo zypper install -y "${packages[@]}"
          elif command -v pacman &> /dev/null; then
            echo "üèπ Detected Arch Linux system"
            sudo pacman -S --noconfirm "${packages[@]}"
          elif command -v apk &> /dev/null; then
            echo "üèîÔ∏è Detected Alpine Linux system"
            sudo apk add --no-cache "${packages[@]}"
          else
            echo "‚ö†Ô∏è Unable to detect package manager. Please install required packages manually: ${packages[*]}"
            return 1
          fi
        }
        
        # Check and install CIFS utilities for network file system support
        if command -v mount.cifs &> /dev/null; then
          echo "‚úÖ CIFS utilities already installed"
        else
          echo "üì• Installing CIFS utilities for network file system support..."
          install_packages cifs-utils
          echo "‚úÖ CIFS utilities installed successfully"
        fi
        
        # Verify OpenSSL installation (required for TLS certificates)
        if ! command -v openssl &> /dev/null; then
          echo "üì• Installing OpenSSL for TLS certificate generation..."
          install_packages openssl
        fi
        echo "‚úÖ OpenSSL is available: $(openssl version)"
        
        echo "::endgroup::"

    # ============================================================================
    # TLS CERTIFICATE GENERATION
    # ============================================================================
    - name: üîê Generate Docker TLS certificates
      id: generate-tls-certs
      shell: bash
      if: ${{ inputs.enable-tls == 'true' }}
      run: |
        echo "::group::üîê Generating TLS Certificates"
        
        # Certificate configuration
        readonly CERT_VALIDITY_DAYS=365
        readonly KEY_SIZE=4096
        readonly TLS_DIR="docker-tls"
        readonly CLIENT_CERT_DIR="docker-client-certs"
        
        echo "üìã TLS Certificate Configuration:"
        echo "  - Key Size: ${KEY_SIZE} bits"
        echo "  - Validity: ${CERT_VALIDITY_DAYS} days"
        echo "  - Domains: ${{ inputs.tls-certificate-domains }}"
        
        # Create certificate directory structure
        echo "üìÅ Creating certificate directories..."
        mkdir -p "${TLS_DIR}"/{server,client}
        mkdir -p "${CLIENT_CERT_DIR}"
        
        # Generate Certificate Authority (CA)
        echo "üèõÔ∏è Generating Certificate Authority..."
        openssl genrsa -out "${TLS_DIR}/ca-private-key.pem" ${KEY_SIZE}
        openssl req -new -x509 -days ${CERT_VALIDITY_DAYS} \
          -key "${TLS_DIR}/ca-private-key.pem" -sha256 \
          -out "${TLS_DIR}/ca-certificate.pem" \
          -subj "/C=US/ST=Docker/L=Daemon/O=Docker/OU=CA/CN=Docker CA"
        
        echo "‚úÖ Certificate Authority generated"
        
        # Generate server certificates
        echo "üñ•Ô∏è Generating server certificates..."
        openssl genrsa -out "${TLS_DIR}/server/private-key.pem" ${KEY_SIZE}
        openssl req -subj "/C=US/ST=Docker/L=Daemon/O=Docker/OU=Server/CN=docker-daemon" \
          -sha256 -new -key "${TLS_DIR}/server/private-key.pem" \
          -out "${TLS_DIR}/server/certificate-request.csr"
        
        # Configure server certificate extensions with domain support
        CERT_DOMAINS="$(echo "${{ inputs.tls-certificate-domains }}" | sed 's/,/,DNS:/g' | sed 's/^/DNS:/')"
        cat > "${TLS_DIR}/server/extensions.cnf" <<EOF
        [v3_req]
        subjectAltName = ${CERT_DOMAINS},IP:127.0.0.1,IP:0.0.0.0
        extendedKeyUsage = serverAuth
        keyUsage = digitalSignature,keyEncipherment
        EOF
        
        # Sign server certificate
        openssl x509 -req -days ${CERT_VALIDITY_DAYS} -sha256 \
          -in "${TLS_DIR}/server/certificate-request.csr" \
          -CA "${TLS_DIR}/ca-certificate.pem" \
          -CAkey "${TLS_DIR}/ca-private-key.pem" \
          -CAcreateserial \
          -out "${TLS_DIR}/server/certificate.pem" \
          -extensions v3_req \
          -extfile "${TLS_DIR}/server/extensions.cnf"
        
        echo "‚úÖ Server certificates generated"
        
        # Generate client certificates
        echo "üíª Generating client certificates..."
        openssl genrsa -out "${TLS_DIR}/client/key.pem" ${KEY_SIZE}
        openssl req -subj "/C=US/ST=Docker/L=Client/O=Docker/OU=Client/CN=docker-client" \
          -new -key "${TLS_DIR}/client/key.pem" \
          -out "${TLS_DIR}/client/certificate-request.csr"
        
        # Configure client certificate extensions
        cat > "${TLS_DIR}/client/extensions.cnf" <<EOF
        [v3_req]
        extendedKeyUsage = clientAuth
        keyUsage = digitalSignature,keyEncipherment
        EOF
        
        # Sign client certificate
        openssl x509 -req -days ${CERT_VALIDITY_DAYS} -sha256 \
          -in "${TLS_DIR}/client/certificate-request.csr" \
          -CA "${TLS_DIR}/ca-certificate.pem" \
          -CAkey "${TLS_DIR}/ca-private-key.pem" \
          -CAcreateserial \
          -out "${TLS_DIR}/client/cert.pem" \
          -extensions v3_req \
          -extfile "${TLS_DIR}/client/extensions.cnf"
        
        # Prepare client certificates with Docker-standard naming
        cp "${TLS_DIR}/ca-certificate.pem" "${TLS_DIR}/client/ca.pem"
        cp "${TLS_DIR}/client/ca.pem" "${CLIENT_CERT_DIR}/"
        cp "${TLS_DIR}/client/cert.pem" "${CLIENT_CERT_DIR}/"
        cp "${TLS_DIR}/client/key.pem" "${CLIENT_CERT_DIR}/"
        
        echo "‚úÖ Client certificates generated"
        
        # Set secure permissions
        echo "üîí Setting secure file permissions..."
        chmod 0400 "${TLS_DIR}/ca-private-key.pem" "${TLS_DIR}/server/private-key.pem" "${TLS_DIR}/client/key.pem" "${CLIENT_CERT_DIR}/key.pem"
        chmod 0444 "${TLS_DIR}/ca-certificate.pem" "${TLS_DIR}/server/certificate.pem" "${TLS_DIR}/client/cert.pem" "${CLIENT_CERT_DIR}"/{ca,cert}.pem
        
        # Cleanup temporary files
        echo "üßπ Cleaning up temporary files..."
        rm -rf "${TLS_DIR}"/*/certificate-request.csr "${TLS_DIR}"/*/extensions.cnf
        
        # Verify certificates
        echo "üîç Verifying generated certificates..."
        echo "  - CA Certificate:"
        openssl x509 -in "${TLS_DIR}/ca-certificate.pem" -noout -subject -dates
        echo "  - Server Certificate:"
        openssl x509 -in "${TLS_DIR}/server/certificate.pem" -noout -subject -dates
        echo "  - Client Certificate:"
        openssl x509 -in "${TLS_DIR}/client/cert.pem" -noout -subject -dates
        
        echo "‚úÖ TLS certificates generated and verified successfully"
        echo "::endgroup::"

    # ============================================================================
    # DOCKER DAEMON CONFIGURATION
    # ============================================================================
    - name: üê≥ Configure and start Docker daemon
      id: docker-config
      shell: bash
      run: |
        echo "::group::üê≥ Docker Daemon Configuration"
        
        # Docker daemon configuration variables
        readonly DOCKER_CONFIG_FILE="/etc/docker/daemon.json"
        readonly DOCKER_SERVICE_OVERRIDE="/etc/systemd/system/docker.service.d/override.conf"
        readonly DOCKER_TLS_PORT=2376
        readonly DOCKER_NON_TLS_PORT=2375
        readonly MAX_STARTUP_RETRIES=30
        readonly STARTUP_RETRY_INTERVAL=2
        
        # Determine Docker configuration based on TLS setting
        if [[ "${{ inputs.enable-tls }}" == "true" ]]; then
          echo "üîê Configuring Docker daemon with TLS encryption..."
        
          # Create TLS-enabled Docker daemon configuration
          sudo tee "$DOCKER_CONFIG_FILE" > /dev/null <<EOF
        {
          "tls": true,
          "tlsverify": true,
          "tlscacert": "$(pwd)/docker-tls/ca-certificate.pem",
          "tlscert": "$(pwd)/docker-tls/server/certificate.pem",
          "tlskey": "$(pwd)/docker-tls/server/private-key.pem",
          "hosts": ["fd://", "unix:///var/run/docker.sock", "tcp://0.0.0.0:${DOCKER_TLS_PORT}"],
          "log-driver": "json-file",
          "log-opts": {
            "max-size": "10m",
            "max-file": "3"
          }
        }
        EOF
        
          DOCKER_PORT=$DOCKER_TLS_PORT
          TLS_ENABLED="1"
          DOCKER_HOST="tcp://localhost:${DOCKER_PORT}"
        
          echo "‚úÖ TLS configuration applied (port: ${DOCKER_PORT})"
        
        else
          echo "‚ö†Ô∏è Configuring Docker daemon WITHOUT TLS encryption..."
          echo "Running Docker daemon without TLS is not recommended for production use"
        
          # Create non-TLS Docker daemon configuration
          sudo tee "$DOCKER_CONFIG_FILE" > /dev/null <<EOF
        {
          "hosts": ["fd://", "unix:///var/run/docker.sock", "tcp://0.0.0.0:${DOCKER_NON_TLS_PORT}"],
          "log-driver": "json-file",
          "log-opts": {
            "max-size": "10m",
            "max-file": "3"
          }
        }
        EOF
        
          DOCKER_PORT=$DOCKER_NON_TLS_PORT
          TLS_ENABLED=""
          DOCKER_HOST="tcp://localhost:${DOCKER_PORT}"
        
          echo "‚úÖ Non-TLS configuration applied (port: ${DOCKER_PORT})"
        fi
        
        echo "üìã Docker daemon configuration:"
        cat "$DOCKER_CONFIG_FILE" | jq '.' || cat "$DOCKER_CONFIG_FILE"
        
        # Configure systemd service override to prevent conflicts
        echo "‚öôÔ∏è Configuring systemd service override..."
        sudo mkdir -p "$(dirname "$DOCKER_SERVICE_OVERRIDE")"
        sudo tee "$DOCKER_SERVICE_OVERRIDE" > /dev/null <<EOF
        [Service]
        ExecStart=
        ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock
        EOF
        
        # Restart Docker service with new configuration
        echo "üîÑ Restarting Docker daemon with new configuration..."
        sudo systemctl daemon-reload
        sudo systemctl restart docker
        
        # Configure Docker client environment
        echo "üîß Setting up Docker client environment..."
        export DOCKER_HOST="$DOCKER_HOST"
        
        if [[ "${{ inputs.enable-tls }}" == "true" ]]; then
          export DOCKER_TLS_VERIFY="1"
          export DOCKER_CERT_PATH="$(pwd)/docker-client-certs"
          echo "üîê Docker client configured with TLS:"
          echo "  - DOCKER_HOST: $DOCKER_HOST"
          echo "  - DOCKER_TLS_VERIFY: $DOCKER_TLS_VERIFY"
          echo "  - DOCKER_CERT_PATH: $DOCKER_CERT_PATH"
        
          # Verify client certificates
          echo "üìÅ Client certificate files:"
          ls -la "$DOCKER_CERT_PATH"
        else
          unset DOCKER_TLS_VERIFY
          unset DOCKER_CERT_PATH
          echo "üîì Docker client configured without TLS:"
          echo "  - DOCKER_HOST: $DOCKER_HOST"
        fi
        
        # Wait for Docker daemon to become ready
        echo "‚è≥ Waiting for Docker daemon to become ready..."
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_STARTUP_RETRIES ]; do
          if timeout 10 docker version > /dev/null 2>&1; then
            echo "‚úÖ Docker daemon is responding successfully!"
            break
          fi
        
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "‚è≥ Waiting for Docker daemon (attempt ${RETRY_COUNT}/${MAX_STARTUP_RETRIES})..."
          sleep $STARTUP_RETRY_INTERVAL
        done
        
        # Handle startup failure
        if [ $RETRY_COUNT -eq $MAX_STARTUP_RETRIES ]; then
          echo "‚ùå Docker daemon failed to start within timeout period"
          echo "üîç Docker service logs (last 50 lines):"
          sudo journalctl -u docker --no-pager --lines=50
          echo "üîç Docker daemon configuration:"
          cat "$DOCKER_CONFIG_FILE" || echo "Configuration file not found"
          exit 1
        fi
        
        # Display Docker daemon information
        echo "üìä Docker daemon information:"
        docker version --format 'table'
        docker system info --format 'table'
        
        # Save connection details for artifacts
        echo "üíæ Saving connection configuration..."
        cat > docker-connection-details.env <<EOF
        DOCKER_HOST=${DOCKER_HOST}
        DOCKER_TLS_VERIFY=${TLS_ENABLED}
        DOCKER_PORT=${DOCKER_PORT}
        DOCKER_CERT_PATH=$(pwd)/docker-client-certs
        EOF
        
        # Set outputs for other steps
        echo "docker-host=${DOCKER_HOST}" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Docker daemon configured and ready for remote connections"
        echo "::endgroup::"

    # ============================================================================
    # SSH SERVER SETUP
    # ============================================================================
    - name: üîë Expose SSH server for remote access
      id: ssh-server
      uses: lexbritvin/ssh-session-action@main
      with:
        ssh-server-host: ${{ inputs.ssh-server-host }}
        ssh-server-user: ${{ inputs.ssh-server-user }}
        ssh-server-port: ${{ inputs.ssh-server-port }}
        ssh-server-authorized-keys: ${{ inputs.ssh-server-authorized-keys }}
        ssh-jump-user: ${{ inputs.ssh-jump-user }}
        ssh-jump-host: ${{ inputs.ssh-jump-host }}
        ssh-jump-port: ${{ inputs.ssh-jump-port }}
        ssh-jump-host-keys: ${{ inputs.ssh-jump-host-keys }}
        ssh-jump-forward: ${{ inputs.ssh-jump-forward }}
        ssh-jump-private-key: ${{ inputs.ssh-jump-private-key }}
        ssh-jump-private-key-path: ${{ inputs.ssh-jump-private-key-path }}
        ssh-jump-extra-flags: ${{ inputs.ssh-jump-extra-flags }}
        use-bore: ${{ inputs.use-bore }}
        bore-server: ${{ inputs.bore-server }}
        bore-secret: ${{ inputs.bore-secret }}
        wait-file: ''
        display-help-message: 'false'

    # ============================================================================
    # CONNECTION ARTIFACTS PREPARATION
    # ============================================================================
    - name: üì¶ Prepare connection artifacts
      shell: bash
      env:
        SSH_HOST: ${{ steps.ssh-server.outputs.ssh-host }}
        SSH_PORT: ${{ steps.ssh-server.outputs.ssh-port }}
        SSH_HOST_KEYS: "${{ steps.ssh-server.outputs.ssh-host-keys }}"
        JUMP_HOST_KEYS: "${{ inputs.ssh-jump-host-keys }}"
      run: |
        echo "::group::üì¶ Preparing Connection Artifacts"
        
        readonly ARTIFACT_DIR="${{ inputs.docker-connection-artifact-name }}"
        readonly TLS_CERT_DIR="${ARTIFACT_DIR}/tls-certificates"
        
        echo "üìÅ Creating artifact directory structure..."
        mkdir -p "$ARTIFACT_DIR"
        
        # Create comprehensive SSH connection details
        echo "üîë Generating SSH connection configuration..."
        cat > ssh-connection-details.env <<EOF
        # SSH Connection Configuration
        # Generated by Secure Docker Remote Access Action
        SSH_HOST=${SSH_HOST}
        SSH_PORT=${SSH_PORT}
        SSH_USER=${{ steps.ssh-server.outputs.ssh-user }}
        SSH_JUMP_HOST=${{ steps.ssh-server.outputs.ssh-jump-host }}
        SSH_JUMP_PORT=${{ steps.ssh-server.outputs.ssh-jump-port }}
        SSH_JUMP_USER=${{ steps.ssh-server.outputs.ssh-jump-user }}
        
        # Docker Connection Details
        DOCKER_HOST=${{ steps.docker-config.outputs.docker-host }}
        DOCKER_TLS_VERIFY=${{ inputs.enable-tls == 'true' && '1' || '' }}
        DOCKER_PORT=${{ inputs.enable-tls == 'true' && '2376' || '2375' }}
        EOF
        
        # Generate SSH known_hosts file for secure connections
        echo "üîê Processing SSH host keys for known_hosts..."
        KNOWN_HOSTS_CONTENT=""
        
        # Add SSH server host keys
        if [[ -n "$SSH_HOST_KEYS" ]]; then
          while IFS= read -r key_line; do
            if [[ -n "$key_line" && ! "$key_line" =~ ^[[:space:]]*# ]]; then
              # Format host keys with proper hostname:port syntax
              if [[ "$SSH_PORT" != "22" ]]; then
                KNOWN_HOSTS_CONTENT="${KNOWN_HOSTS_CONTENT}[${SSH_HOST}]:${SSH_PORT} ${key_line}"$'\n'
              else
                KNOWN_HOSTS_CONTENT="${KNOWN_HOSTS_CONTENT}${SSH_HOST} ${key_line}"$'\n'
              fi
            fi
          done <<< "$SSH_HOST_KEYS"
        fi
        
        # Add jump host keys if available
        if [[ -n "$JUMP_HOST_KEYS" ]]; then
          KNOWN_HOSTS_CONTENT="${KNOWN_HOSTS_CONTENT}${JUMP_HOST_KEYS}"$'\n'
        fi
        
        # Save known_hosts file (remove trailing newline)
        echo -n "$KNOWN_HOSTS_CONTENT" > ssh-known-hosts.txt
        
        # Copy all configuration files to artifact directory
        echo "üìã Copying configuration files to artifact directory..."
        cp docker-connection-details.env "$ARTIFACT_DIR/"
        cp ssh-connection-details.env "$ARTIFACT_DIR/"
        cp ssh-known-hosts.txt "$ARTIFACT_DIR/"
        
        # Add TLS certificates if enabled
        if [[ "${{ inputs.enable-tls }}" == "true" ]]; then
          echo "üîê Adding TLS certificates to artifacts..."
          mkdir -p "$TLS_CERT_DIR"
          cp docker-client-certs/{ca,cert,key}.pem "$TLS_CERT_DIR/"
        
          # Verify certificate files
          echo "üìã TLS certificate files added:"
          ls -la "$TLS_CERT_DIR"
        fi
        
        # Display artifact summary
        echo "üìä Artifact Summary:"
        echo "  - Directory: $ARTIFACT_DIR"
        echo "  - Files created: $(find "$ARTIFACT_DIR" -type f | wc -l)"
        echo "  - Total size: $(du -sh "$ARTIFACT_DIR" | cut -f1)"
        echo ""
        echo "üìÅ Artifact contents:"
        find "$ARTIFACT_DIR" -type f -exec ls -lh {} \;
        
        echo "‚úÖ Connection artifacts prepared successfully"
        echo "::endgroup::"

    # ============================================================================
    # ARTIFACT UPLOAD
    # ============================================================================
    - name: ‚¨ÜÔ∏è Upload connection artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.docker-connection-artifact-name }}
        path: ${{ inputs.docker-connection-artifact-name }}/
        retention-days: 1
        if-no-files-found: error
        compression-level: 6

    # ============================================================================
    # SUCCESS SUMMARY
    # ============================================================================
    - name: ‚úÖ Setup completion summary
      shell: bash
      run: |
        echo "::group::‚úÖ Setup Completion Summary"
        
        echo "üéâ Secure Docker Remote Access Setup Complete!"
        echo "=============================================="
        echo ""
        echo "üìã Configuration Summary:"
        echo "  - TLS Encryption: ${{ inputs.enable-tls == 'true' && '‚úÖ Enabled' || '‚ùå Disabled' }}"
        echo "  - Docker Port: ${{ inputs.enable-tls == 'true' && '2376 (TLS)' || '2375 (Non-TLS)' }}"
        echo "  - SSH Host: ${{ steps.ssh-server.outputs.ssh-host }}"
        echo "  - SSH Port: ${{ steps.ssh-server.outputs.ssh-port }}"
        echo "  - SSH User: ${{ steps.ssh-server.outputs.ssh-user }}"
        echo "  - Artifact Name: ${{ inputs.docker-connection-artifact-name }}"
        echo ""
        echo "üì¶ Next Steps:"
        echo "  1. Download the '${{ inputs.docker-connection-artifact-name }}' artifact"
        echo "  2. Extract and use the connection files"
        echo "  3. Test with 'docker version' command"
        echo ""
        echo "üîí Security Reminders:"
        echo "  - Keep TLS certificates and SSH keys secure"
        echo "  - Do not commit connection artifacts to version control"
        echo "  - Use strong SSH authentication methods"
        echo "  - Regularly rotate certificates and keys"
        
        echo "::endgroup::"
